# -*- coding: utf-8 -*-
"""김솔.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u-p9-ZwkmYWZ4Wwa4EeeAo7UoxkVJR9j

# 출력할 라벨 개수 지정

## 구글 드라이브
"""

!pip install --upgrade google-cloud-vision google-cloud-storage google-auth

import os
from google.cloud import vision
from google.oauth2 import service_account
import pandas as pd

# 구글 드라이브 마운트
from google.colab import drive
drive.mount('/content/drive')

# Google Cloud 서비스 계정 키 파일의 경로를 지정
credentials_path = '/content/drive/MyDrive/label-395611-54d29a7c94db.json'

# 이미지 파일이 들어있는 최상위 폴더 경로
top_image_directory = '/content/drive/MyDrive/image'

# 이미지 파일 확장자
image_extensions = ('.png', '.jpg', '.jpeg')

credentials = service_account.Credentials.from_service_account_file(credentials_path)
client = vision.ImageAnnotatorClient(credentials=credentials)



# 최상위 폴더 내의 하위 폴더 목록 가져오기
subfolders = [f.path for f in os.scandir(top_image_directory) if f.is_dir()]

# 모든 데이터를 저장할 리스트 초기화
all_data = []

# 각 하위 폴더에 대해 데이터 생성
for folder_path in subfolders:
    folder_name = os.path.basename(folder_path)

    # 하위 폴더 내의 이미지 파일에 대해 라벨 감지
    for root, dirs, files in os.walk(folder_path):
        for image_file in files:
            if image_file.lower().endswith(image_extensions):
                image_path = os.path.join(root, image_file)

                # 이미지 파일을 열어 바이너리로 읽음
                with open(image_path, 'rb') as file:
                    content = file.read()

                # Vision API를 사용하여 이미지의 라벨을 감지
                image = vision.Image(content=content)
                response = client.label_detection(image=image)

                # 감지된 각 라벨 정보를 별도의 행으로 저장
                for label in response.label_annotations:
                    label_description = label.description
                    score = label.score
                    data_entry = {
                        'Folder': folder_name,
                        'Filename': image_file,
                        'Label': label_description,
                        'Score': score
                    }
                    all_data.append(data_entry)

# 데이터프레임 생성
df = pd.DataFrame(all_data)

# 데이터프레임 출력
print(df)

# 데이터프레임을 CSV 파일로 저장
df.to_csv('/content/drive/MyDrive/all_image_labels.csv', index=False)



import os
import csv
import requests
from IPython.display import Image, display
from google.colab import drive

# Google 드라이브 마운트
drive.mount('/content/drive')

# Flickr API 정보
FLICKR_API_KEY = '001032c601589bc3a115fe7d4dab744f'

# 플리커 API 엔드포인트
endpoint = 'https://www.flickr.com/services/rest/'

# 검색 파라미터(매개변수) 설정
def build_params(search_keyword, location, num_photos, page):
    params = {
        'method': 'flickr.photos.search',
        'api_key': FLICKR_API_KEY,
        'text': f'{search_keyword} {location}',
        'sort': 'relevance',
        'per_page': num_photos,
        'page': page,
        'format': 'json',
        'nojsoncallback': 1,
        'extras': 'owner_name,title,date_taken,tags,geo,description,views,comments,count_faves'
    }
    return params

# 이미지 저장 폴더 생성
def create_image_folder(image_folder):
    if not os.path.exists(image_folder):
        os.makedirs(image_folder)

# 이미지 다운로드 및 CSV 파일 작성
def download_images_and_create_csv(params, image_folder, csv_filename):
    response = requests.get(endpoint, params=params)
    data = response.json()

    if data.get('photos'):
        photos = data['photos']['photo']

        with open(csv_filename, mode='w', newline='', encoding='utf-8') as csv_file:
            fieldnames = ['Image ID', 'Title', 'URL', 'Taken Date', 'Tags', 'Description', 'Author (Owner)', 'Photographer (Ownername)', 'Latitude', 'Longitude', 'Views', 'Comments', 'Favorites']
            writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
            writer.writeheader()

            for photo in photos:
                image_id = photo['id']
                image_path = os.path.join(image_folder, f"{image_id}.jpg")

                if os.path.exists(image_path):
                    print(f"Image {image_id}.jpg already exists. Skipping...")
                    continue

                # 호스트 이름을 직접 IP 주소로 변환하여 사용
                photo_url = f"https://farm{photo['farm']}.staticflickr.com/{photo['server']}/{photo['id']}_{photo['secret']}_b.jpg"
                image_data = requests.get(photo_url, verify=False).content

                with open(image_path, 'wb') as img_file:
                    img_file.write(image_data)


                image_info = {
                    'Image ID': photo['id'],
                    'Title': photo['title'],
                    'URL': photo_url,
                    'Taken Date': photo['datetaken'],
                    'Tags': photo['tags'],
                    'Description': photo.get('description', {}).get('_content', None),
                    'Author (Owner)': photo['owner'],
                    'Photographer (Ownername)': photo['ownername'],
                    'Latitude': photo.get('latitude', 0),
                    'Longitude': photo.get('longitude', 0),
                    'Views': photo.get('views', 0),
                    'Comments': photo.get('comments', 0),
                    'Favorites': photo.get('count_faves', 0)
                }
                writer.writerow(image_info)

                display(Image(image_path, width=300))
                print("Image Information:")
                print(f"Image ID: {photo['id']}")
                print(f"Image Title: {photo['title']}")
                print(f"Image Taken Date: {photo['datetaken']}")
                print(f"Image Tags: {', '.join(photo['tags'].split())}")
                print(f"Image Description: {photo.get('description', {}).get('_content', None)}")
                print(f"Author (Owner): {photo['owner']}")
                print(f"Photographer (Ownername): {photo['ownername']}")
                print(f"Latitude: {photo.get('latitude', 0)}")
                print(f"Longitude: {photo.get('longitude', 0)}")
                print(f"Views: {photo.get('views', 0)}")
                print(f"Comments: {photo.get('comments', 0)}")
                print(f"Favorites: {photo.get('count_faves', 0)}")
                print('=' * 50)

# 검색할 키워드와 검색 결과 수
search_keyword = 'New York'
location = 'cityscape'
total_num_photos = 1000  # 다운로드할 총 이미지 수
num_photos_per_request = 500  # 한 번의 요청으로 가져올 이미지 수
csv_filename = '/content/drive/MyDrive/Flickr_Images/flickr_images.csv'

# 이미지 저장 폴더 생성
image_folder = '/content/drive/MyDrive/Flickr_Images'
create_image_folder(image_folder)

# 이미지 다운로드 및 CSV 파일 작성
num_pages = total_num_photos // num_photos_per_request
for page in range(1, num_pages + 1):
    params = build_params(search_keyword, location, num_photos_per_request, page)
    download_images_and_create_csv(params, image_folder, csv_filename)

import os
import requests
import json
from IPython.display import Image, display
from google.colab import drive

# Google Drive 마운트
drive.mount('/content/drive')

# Flickr API 정보
FLICKR_API_KEY = '001032c601589bc3a115fe7d4dab744f'

# 플리커 API 엔드포인트
endpoint = 'https://www.flickr.com/services/rest/'

# 검색 파라미터(매개변수) 설정
def build_params(search_keyword, location, num_photos, page):
    params = {
        'method': 'flickr.photos.search',
        'api_key': FLICKR_API_KEY,
        'text': f'{search_keyword} {location}',
        'sort': 'relevance',
        'per_page': num_photos,
        'page': page,
        'format': 'json',
        'nojsoncallback': 1,
        'extras': 'owner_name,title,date_taken,tags,geo,description,views,comments,count_faves'
    }
    return params

# 이미지 저장 폴더 생성
def create_image_folder(image_folder):
    if not os.path.exists(image_folder):
        os.makedirs(image_folder)

# 이미지 다운로드 및 이미지 정보 저장
def download_images_and_save_info(params, image_folder):
    response = requests.get(endpoint, params=params)
    data = response.json()

    if data.get('photos'):
        photos = data['photos']['photo']

        for photo in photos:
            image_id = photo['id']
            image_path = os.path.join(image_folder, f"{image_id}.jpg")

            if os.path.exists(image_path):
                print(f"Image {image_id}.jpg already exists. Skipping...")
                continue

            photo_url = f"https://farm{photo['farm']}.staticflickr.com/{photo['server']}/{photo['id']}_{photo['secret']}_b.jpg"
            image_data = requests.get(photo_url).content

            with open(image_path, 'wb') as img_file:
                img_file.write(image_data)

            image_info = {
                'Image ID': photo['id'],
                'Title': photo['title'],
                'URL': photo_url,
                'Taken Date': photo['datetaken'],
                'Tags': photo['tags'],
                'Description': photo.get('description', {}).get('_content', None),
                'Author (Owner)': photo['owner'],
                'Photographer (Ownername)': photo['ownername'],
                'Latitude': photo.get('latitude', 0),
                'Longitude': photo.get('longitude', 0),
                'Views': photo.get('views', 0),
                'Comments': photo.get('comments', 0),
                'Favorites': photo.get('count_faves', 0)
            }

            info_filename = os.path.join(image_folder, f"{image_id}_info.json")
            with open(info_filename, 'w', encoding='utf-8') as info_file:
                json.dump(image_info, info_file, indent=4, ensure_ascii=False)

            display(Image(image_path, width=300))
            print(f"Image ID: {photo['id']}")
            print(f"Image Title: {photo['title']}")
            print(f"Image Taken Date: {photo['datetaken']}")
            print(f"Image Tags: {', '.join(photo['tags'].split())}")
            print(f"Image Description: {photo.get('description', {}).get('_content', None)}")
            print(f"Author (Owner): {photo['owner']}")
            print(f"Photographer (Ownername): {photo['ownername']}")
            print(f"Latitude: {photo.get('latitude', 0)}")
            print(f"Longitude: {photo.get('longitude', 0)}")
            print(f"Views: {photo.get('views', 0)}")
            print(f"Comments: {photo.get('comments', 0)}")
            print(f"Favorites: {photo.get('count_faves', 0)}")
            print('-' * 50)
    else:
        print("No photos found.")

# 검색할 키워드와 검색 결과 수
search_keyword = 'New York'
location = 'cityscape'
total_num_photos = 1000  # 다운로드할 총 이미지 수
num_photos_per_request = 500  # 한 번의 요청으로 가져올 이미지 수

# 이미지 저장 폴더 생성
image_folder = '/content/drive/MyDrive/Flickr_Images'
create_image_folder(image_folder)

# 이미지 다운로드 및 정보 저장
num_pages = total_num_photos // num_photos_per_request
for page in range(1, num_pages + 1):
    params = build_params(search_keyword, location, num_photos_per_request, page)
    download_images_and_save_info(params, image_folder)



# Google Cloud 서비스 계정 키 파일의 경로를 지정
credentials_path = '/content/drive/MyDrive/label-395611-54d29a7c94db.json'

# 이미지 파일이 들어있는 폴더 경로
image_directory = '/content/drive/MyDrive/Flickr_Images'

# 이미지 파일 확장자
image_extensions = ('.png', '.jpg', '.jpeg')

# Vision API 클라이언트 설정
credentials = service_account.Credentials.from_service_account_file(credentials_path)
client = vision.ImageAnnotatorClient(credentials=credentials)

# 모든 데이터를 저장할 리스트 초기화
all_data = []



# 이미지 파일에 대해 라벨 감지
for root, dirs, files in os.walk(image_directory):
    for image_file in files:
        if image_file.lower().endswith(image_extensions):
            image_path = os.path.join(root, image_file)

            # 이미지 파일을 열어 바이너리로 읽음
            with open(image_path, 'rb') as file:
                content = file.read()

            # Vision API를 사용하여 이미지의 라벨을 감지
            image = vision.Image(content=content)
            response = client.label_detection(image=image)

            # 감지된 각 라벨 정보를 별도의 행으로 저장
            for label in response.label_annotations:
                label_description = label.description
                score = label.score
                data_entry = {
                    'Filename': image_file,
                    'Label': label_description,
                    'Score': score
                }
                all_data.append(data_entry)

# 데이터프레임 생성
df = pd.DataFrame(all_data)



# 데이터프레임 출력
print(df)

# 데이터프레임을 CSV 파일로 저장
df.to_csv('/content/drive/MyDrive/Flickr_Images_labels.csv', index=False)





"""# 라벨 개수 늘리기"""

# 필요한 라이브러리 임포트
import os
from google.cloud import vision
from google.oauth2 import service_account

# Google Cloud 서비스 계정 키 파일의 경로를 지정
credentials_path = '/content/drive/MyDrive/label-395611-54d29a7c94db.json'
# 이미지 파일이 들어있는 폴더 경로
image_directory = '/content/drive/MyDrive/Flickr_Images'
# 이미지 파일 확장자
image_extensions = ('.png', '.jpg', '.jpeg')

# Vision API 클라이언트 설정
credentials = service_account.Credentials.from_service_account_file(credentials_path)
client = vision.ImageAnnotatorClient(credentials=credentials)

# 이미지 파일별로 라벨 결과 저장을 위한 딕셔너리 초기화
image_labels = {}

for root, dirs, files in os.walk(image_directory):
    for image_file in files:
        if image_file.lower().endswith(image_extensions):
            image_path = os.path.join(root, image_file)

            # 이미지 파일을 열어 바이너리로 읽음
            with open(image_path, 'rb') as file:
                content = file.read()

            # Vision API를 사용하여 이미지의 라벨을 감지
            image = vision.Image(content=content)
            response = client.label_detection(image=image)

            # 최대 100개의 라벨 결과 저장
            label_descriptions = [label.description for label in response.label_annotations]
            image_labels[image_file] = label_descriptions

# 라벨 결과 출력
for image_file, labels in image_labels.items():
    print(f"Image: {image_file}")
    for i, label in enumerate(labels, start=1):
        print(f"Label {i}: {label}")







